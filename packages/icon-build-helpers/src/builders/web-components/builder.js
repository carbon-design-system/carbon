/**
 * Copyright IBM Corp. 2024
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

const { babel } = require('@rollup/plugin-babel');
const path = require('path');
const { rollup } = require('rollup');
const virtual = require('../plugins/virtual');

const BANNER = `/**
 * Copyright IBM Corp. 2024
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */`;

const external = ['@carbon/icon-helpers', 'lit', 'lit-html'];
const babelConfig = {
  babelrc: false,
  exclude: /node_modules/,
  presets: [
    [
      '@babel/preset-env',
      {
        targets: {
          browsers: ['extends browserslist-config-carbon'],
        },
      },
    ],
  ],
  babelHelpers: 'bundled',
  extensions: ['.ts', '.js'],
};

async function builder(metadata, { output }) {
  const modules = metadata.icons.flatMap((icon) => {
    return icon.output.map((size) => {
      const source = createIconComponent(size.moduleName, size.descriptor);
      return {
        source,
        filepath: size.filepath,
        moduleName: size.moduleName,
        exportName: size.moduleName,
      };
    });
  });

  // Split modules into buckets for better performance
  const BUCKET_SIZE = 250;
  const BUCKET_COUNT = Math.ceil(modules.length / BUCKET_SIZE);
  const buckets = Array(BUCKET_COUNT);

  for (let i = 0; i < buckets.length; i++) {
    const start = BUCKET_SIZE * i;
    const end = Math.min(start + BUCKET_SIZE, modules.length) - 1;
    const bucket = Array(end - start + 1);

    for (let j = start; j <= end; j++) {
      bucket[j - start] = modules[j];
    }

    buckets[i] = bucket;
  }

  const files = {
    'index.js': `${BANNER}\n\n`,
  };
  const input = {
    'index.js': 'index.js',
  };

  for (const m of modules) {
    files[m.filepath] = m.source;
    input[m.filepath] = m.filepath;
  }

  // Create bucket files for better performance
  for (let i = 0; i < buckets.length; i++) {
    const bucket = buckets[i];
    const filename = `__generated__/bucket-${i}.js`;

    input[filename] = filename;
    files[filename] = `${BANNER}\n\n`;

    for (const m of bucket) {
      files[filename] +=
        `export { default as ${m.exportName} } from '../${m.filepath}';\n`;
    }

    // Add exports to index.js
    for (const m of bucket) {
      files['index.js'] += `export { ${m.exportName} } from '${filename}';\n`;
    }
  }

  const bundle = await rollup({
    input,
    external,
    plugins: [virtual(files), babel(babelConfig)],
  });

  const bundles = [
    {
      directory: path.join(output, 'es'),
      format: 'esm',
    },
    {
      directory: path.join(output, 'lib'),
      format: 'commonjs',
    },
  ];

  for (const { directory, format } of bundles) {
    const outputOptions = {
      dir: directory,
      format,
      entryFileNames: '[name]',
      banner: BANNER,
      exports: 'auto',
    };

    await bundle.write(outputOptions);
  }
}

/**
 * Generate a lit-html icon component from a given moduleName and icon descriptor.
 * @param {string} moduleName
 * @param {object} descriptor
 * @returns {string}
 */
function createIconComponent(moduleName, descriptor) {
  const { attrs, content } = descriptor;
  const { width, height, viewBox, ...rest } = attrs;

  // Convert content to lit-html svg template
  const svgContent = content.map(convertToLitHTML).join('\n');

  // Prepare rest object for code generation
  const restEntries = Object.entries(rest);
  const restObject =
    restEntries.length > 0 ? `, ${JSON.stringify(rest).slice(1, -1)}` : '';

  // Generate code with placeholders
  let code = `${BANNER}

import { svg } from 'lit';
import { getAttributes } from '@carbon/icon-helpers';

const ${moduleName} = ({ children, ...attrs } = {}) => {
  const attributes = getAttributes(Object.assign({ width: ${width}, height: ${height}, viewBox: "${viewBox}"${restObject} }, attrs));
  return svg\`<svg ...=__ATTRIBUTES__>
    ${svgContent}
    __CHILDREN__
  </svg>\`;
};

export default ${moduleName};`;

  // Replace placeholders with actual lit-html syntax
  code = code.replace('__ATTRIBUTES__', '$' + '{attributes}');
  code = code.replace('__CHILDREN__', '$' + "{children || ''}");

  return code;
}

/**
 * Convert an icon content element to lit-html format
 * @param {object} element
 * @returns {string}
 */
function convertToLitHTML(element) {
  if (typeof element === 'string') {
    return element;
  }

  const { elem, attrs = {}, content = [] } = element;
  const children = content.map(convertToLitHTML).join('');
  const formattedAttrs = formatAttributes(attrs);

  if (elem !== 'svg') {
    return `<${elem} ${formattedAttrs}>${children}</${elem}>`;
  }

  return children;
}

/**
 * Format attributes for lit-html
 * @param {object} attrs
 * @returns {string}
 */
function formatAttributes(attrs) {
  return Object.entries(attrs)
    .map(([key, value]) => `${key}="${value}"`)
    .join(' ');
}

module.exports = builder;
